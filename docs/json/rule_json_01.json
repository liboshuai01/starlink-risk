{
  "channel": "game",
  "ruleCode": "ruleCode01",
  "modelCode": "modelCode01",
  "ruleName": "ruleName01",
  "ruleDesc": "ruleDesc01",
  "combinedConditionOperator": 0,
  "warnMessage": "高频抽奖触发",
  "warnInterval": 180000,
  "status": 1,
  "ruleConditionGroup": [
    {
      "ruleCode": "ruleCode01",
      "eventCode": "eventCode01",
      "eventThreshold": 10,
      "conditionType": 1,
      "beginTime": "1970-01-01 00:00:00",
      "endTime": "1970-01-01 00:00:00",
      "windowSize": 300000,
      "isCrossHistory": true,
      "crossHistoryTimeline": "2024-08-26 16:41:40",
      "eventInfo": {
        "eventCode": "eventCode01",
        "channel": "game",
        "eventName": "抽奖",
        "eventDesc": "游戏抽奖",
        "eventAttributeGroup": [
          {
            "eventCode": "eventCode01",
            "fieldName": "campaignId",
            "fieldDesc": "活动ID"
          },
          {
            "eventCode": "eventCode01",
            "fieldName": "campaignName",
            "fieldDesc": "活动名称"
          }
        ]
      }
    },
    {
      "ruleCode": "ruleCode01",
      "eventCode": "eventCode02",
      "eventThreshold": 20,
      "conditionType": 1,
      "beginTime": "1970-01-01 00:00:00",
      "endTime": "1970-01-01 00:00:00",
      "windowSize": 600000,
      "isCrossHistory": true,
      "crossHistoryTimeline": "2024-08-26 16:41:40",
      "eventInfo": {
        "eventCode": "eventCode02",
        "channel": "game",
        "eventName": "充值",
        "eventDesc": "游戏充值",
        "eventAttributeGroup": [
          {
            "eventCode": "eventCode02",
            "fieldName": "campaignId",
            "fieldDesc": "活动ID"
          },
          {
            "eventCode": "eventCode02",
            "fieldName": "campaignName",
            "fieldDesc": "活动名称"
          }
        ]
      }
    }
  ],
  "ruleModelGroovyCode": "package com.liboshuai.starlink.slr.engine.processor.impl;\n\nimport com.liboshuai.starlink.slr.engine.api.constants.GlobalConstants;\nimport com.liboshuai.starlink.slr.engine.api.constants.RedisKeyConstants;\nimport com.liboshuai.starlink.slr.engine.api.dto.EventKafkaDTO;\nimport com.liboshuai.starlink.slr.engine.api.dto.RuleConditionDTO;\nimport com.liboshuai.starlink.slr.engine.api.dto.RuleInfoDTO;\nimport com.liboshuai.starlink.slr.engine.api.enums.RuleConditionOperatorTypeEnum;\nimport com.liboshuai.starlink.slr.engine.exception.BusinessException;\nimport com.liboshuai.starlink.slr.engine.processor.Processor;\nimport com.liboshuai.starlink.slr.engine.utils.data.RedisUtil;\nimport com.liboshuai.starlink.slr.engine.utils.date.DateUtil;\nimport com.liboshuai.starlink.slr.engine.utils.string.StringUtil;\nimport org.apache.flink.api.common.functions.RuntimeContext;\nimport org.apache.flink.api.common.state.MapState;\nimport org.apache.flink.api.common.state.MapStateDescriptor;\nimport org.apache.flink.api.common.state.ValueState;\nimport org.apache.flink.api.common.state.ValueStateDescriptor;\nimport org.apache.flink.api.common.typeinfo.Types;\nimport org.apache.flink.util.CollectionUtil;\nimport org.apache.flink.util.Collector;\nimport org.apache.flink.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n/**\n * 运算机one\n */\npublic class ProcessorOne implements Processor {\n\n    private static final Logger log = LoggerFactory.getLogger(ProcessorOne.class);\n\n    /**\n     * 规则信息\n     */\n    private RuleInfoDTO ruleInfo;\n\n    /**\n     * smallValue（窗口步长）: key为eventCode,value为eventValue\n     */\n    private MapState<String, Long> smallMapState;\n\n    /**\n     * bigValue（窗口大小）: key为eventCode，value为一个一个步长的eventValue累加值\n     */\n    private MapState<String, List<Long>> bigMapState;\n\n    /**\n     * 最近一次预警时间\n     */\n    private ValueState<Long> lastWarningTimeState;\n\n    @Override\n    public void open(RuntimeContext runtimeContext, RuleInfoDTO ruleInfoDTO) throws IOException {\n        log.warn(\"调用ProcessorOne对象的open方法, ruleInfoDTO={}\", ruleInfoDTO);\n        String ruleCode = ruleInfoDTO.getRuleCode();\n        ruleInfo = ruleInfoDTO;\n        smallMapState = runtimeContext.getMapState(\n                new MapStateDescriptor<>(\"smallMapState_\" + ruleCode, String.class, Long.class)\n        );\n        bigMapState = runtimeContext.getMapState(\n                new MapStateDescriptor<>(\"bigMapState_\" + ruleCode, Types.STRING, Types.LIST(Types.LONG))\n        );\n        lastWarningTimeState = runtimeContext.getState(\n                new ValueStateDescriptor<>(\"lastWarningTimeState_\" + ruleCode, Long.class)\n        );\n    }\n\n    @Override\n    public void processElement(EventKafkaDTO eventKafkaDTO, Collector<String> out) throws Exception {\n        log.warn(\"调用ProcessorOne对象的processElement方法, eventKafkaDTO={}, out={}\", eventKafkaDTO, out);\n        if (Objects.isNull(ruleInfo)) {\n            throw new BusinessException(\"运算机 ruleInfoDTO 必须非空\");\n        }\n        // 获取当前事件时间戳\n        String timestamp = eventKafkaDTO.getTimestamp();\n        LocalDateTime eventTime = DateUtil.convertTimestamp2LocalDateTime(Long.parseLong(timestamp));\n        // 获取规则条件\n        List<RuleConditionDTO> ruleConditionList = ruleInfo.getRuleConditionGroup();\n        if (CollectionUtil.isNullOrEmpty(ruleConditionList)) {\n            throw new BusinessException(\"运算机 ruleConditionList 必须非空\");\n        }\n        // 多个规则条件进行窗口值累加\n        for (RuleConditionDTO ruleConditionDTO : ruleConditionList) {\n            // 划分为跨历史时间段 和 不跨历史时间段\n            if (ruleConditionDTO.getIsCrossHistory()) { // 跨历史时间段\n                LocalDateTime crossHistoryTimeline = ruleConditionDTO.getCrossHistoryTimeline();\n                // 匹配到事件时，进行事件值累加\n                if (Objects.equals(eventKafkaDTO.getEventCode(), ruleConditionDTO.getEventCode())\n                        && eventTime.isAfter(crossHistoryTimeline)) {\n                    if (smallMapState.get(eventKafkaDTO.getEventCode()) == null) {\n                        // 跨历史时间段，当状态值为空时从redis获取初始值\n                        String key = RedisKeyConstants.DORIS_HISTORY_VALUE\n                                + GlobalConstants.REDIS_KEY_SEPARATOR + ruleConditionDTO.getRuleCode()\n                                + GlobalConstants.REDIS_KEY_SEPARATOR + ruleConditionDTO.getEventCode();\n                        String keyCode = eventKafkaDTO.getKeyCode();\n                        String initValue = RedisUtil.hget(key, keyCode);\n                        if (StringUtils.isNullOrWhitespaceOnly(initValue)) {\n                            throw new BusinessException(StringUtil.format(\"从redis获取初始值必须非空, key:{}, hashKey: {}\", key, keyCode));\n                        }\n                        smallMapState.put(eventKafkaDTO.getEventCode(), Long.parseLong(initValue));\n                    }\n                    smallMapState.put(eventKafkaDTO.getEventCode(),\n                            smallMapState.get(eventKafkaDTO.getEventCode()) + Long.parseLong(eventKafkaDTO.getEventValue()));\n                }\n            } else { // 非跨历史时间段\n                // 匹配到事件时，进行事件值累加\n                if (Objects.equals(eventKafkaDTO.getEventCode(), ruleConditionDTO.getEventCode())) {\n                    if (smallMapState.get(eventKafkaDTO.getEventCode()) == null) {\n                        // 非跨历史时间段，当状态值为空时直接初始化为0\n                        smallMapState.put(eventKafkaDTO.getEventCode(), 0L);\n                    }\n                    smallMapState.put(eventKafkaDTO.getEventCode(),\n                            smallMapState.get(eventKafkaDTO.getEventCode()) + Long.parseLong(eventKafkaDTO.getEventValue()));\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onTimer(long timestamp, Collector<String> out) throws Exception {\n        log.warn(\"调用ProcessorOne对象的onTimer方法, timestamp={}, out={}\", timestamp, out);\n        if (Objects.isNull(ruleInfo)) {\n            throw new BusinessException(\"运算机 ruleInfoDTO 必须非空\");\n        }\n        // 获取规则条件\n        List<RuleConditionDTO> ruleConditionList = ruleInfo.getRuleConditionGroup();\n        if (CollectionUtil.isNullOrEmpty(ruleConditionList)) {\n            throw new BusinessException(\"运算机 ruleConditionList 必须非空\");\n        }\n        // 将规则条件根据事件编号存储到map中，方便后续操作\n        Map<String, RuleConditionDTO> ruleConditionMapByEventCode = new HashMap<>();\n        for (RuleConditionDTO ruleConditionDTO : ruleConditionList) {\n            ruleConditionMapByEventCode.put(ruleConditionDTO.getEventCode(), ruleConditionDTO);\n        }\n        // 将smallMapState的值临时转移到普通的smallMap中，方便数据操作\n        Map<String, Long> smallMap = new HashMap<>();\n        Iterator<Map.Entry<String, Long>> smallIterator = smallMapState.iterator();\n        while (smallIterator.hasNext()) {\n            Map.Entry<String, Long> next = smallIterator.next();\n            smallMap.put(next.getKey(), next.getValue());\n        }\n        // 将bigMapState的值临时转移到普通的bigMap中，方便数据操作\n        Map<String, List<Long>> bigMap = new HashMap<>();\n        Iterator<Map.Entry<String, List<Long>>> bigIterator = bigMapState.iterator();\n        while (bigIterator.hasNext()) {\n            Map.Entry<String, List<Long>> next = bigIterator.next();\n            bigMap.put(next.getKey(), next.getValue());\n        }\n        // 将每个事件窗口步长数据集累加的值，添加到窗口大小数据集中bigMap中\n        for (Map.Entry<String, Long> smallMapEntry : smallMap.entrySet()) {\n            String eventCode = smallMapEntry.getKey();\n            Long eventValue = smallMapEntry.getValue();\n            List<Long> oldEventValueList = bigMap.get(eventCode);\n            if (CollectionUtil.isNullOrEmpty(oldEventValueList)) {\n                oldEventValueList = new ArrayList<>();\n            }\n            oldEventValueList.add(eventValue);\n            bigMap.put(eventCode, oldEventValueList);\n        }\n        // 当前窗口步长的数据已经添加到窗口中了，清空状态\n        smallMapState.clear();\n        // 清理窗口大小之外的数据\n        for (Map.Entry<String, List<Long>> bigMapEntry : bigMap.entrySet()) {\n            String eventCode = bigMapEntry.getKey();\n            List<Long> eventValueList = bigMapEntry.getValue();\n            Long windowSize = ruleConditionMapByEventCode.get(eventCode).getWindowSize();\n            if (eventValueList.size() > windowSize) {\n                eventValueList = eventValueList.subList(eventValueList.size() - 20, eventValueList.size());\n            }\n            bigMap.put(eventCode, eventValueList);\n        }\n        // 将bigMap更新到bigMapState中\n        for (Map.Entry<String, List<Long>> bigMapEntry : bigMap.entrySet()) {\n            String eventCode = bigMapEntry.getKey();\n            List<Long> eventValueList = bigMapEntry.getValue();\n            bigMapState.put(eventCode, eventValueList);\n        }\n        // 判断是否触发规则事件阈值\n        Map<String, Boolean> eventCodeAndWarnResult = new HashMap<>();\n        for (Map.Entry<String, List<Long>> bigMapEntry : bigMap.entrySet()) {\n            String eventCode = bigMapEntry.getKey();\n            List<Long> eventValueList = bigMapEntry.getValue();\n            long eventValueSum = eventValueList.stream().mapToLong(Long::longValue).sum();\n            Long eventThreshold = ruleConditionMapByEventCode.get(eventCode).getEventThreshold();\n            eventCodeAndWarnResult.put(eventCode, eventValueSum > eventThreshold);\n        }\n        Integer conditionOperator = ruleInfo.getCombinedConditionOperator();\n        // 根据规则中事件条件表达式组合判断事件结果 与预警频率 判断否是触发预警\n        boolean eventResult = evaluateEventResults(eventCodeAndWarnResult, conditionOperator);\n        if (eventResult && (timestamp - lastWarningTimeState.value() >= ruleInfo.getWarnInterval())) {\n            lastWarningTimeState.update(timestamp);\n            // TODO: 进行预警信息拼接组合\n            out.collect(\"事件[{}]触发了[{}]规则，事件值超过阈值[{}]，请尽快处理\");\n        }\n    }\n\n    public static boolean evaluateEventResults(Map<String, Boolean> eventCodeAndWarnResult, Integer conditionOperator) {\n        // 初始化结果变量\n        boolean result = conditionOperator.equals(RuleConditionOperatorTypeEnum.AND.getCode());\n\n        // 遍历 Map\n        for (Boolean eventResult : eventCodeAndWarnResult.values()) {\n            if (conditionOperator.equals(RuleConditionOperatorTypeEnum.AND.getCode())) {\n                // 对于 AND，只有当所有结果都为 true 时，结果才为 true\n                result = eventResult;\n                // 提前结束循环，如果结果已经为 false\n                if (!result) {\n                    break;\n                }\n            } else if (conditionOperator.equals(RuleConditionOperatorTypeEnum.OR.getCode())) {\n                // 对于 OR，只要有一个结果为 true，结果就为 true\n                result = eventResult;\n                // 提前结束循环，如果结果已经为 true\n                if (result) {\n                    break;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n"
}