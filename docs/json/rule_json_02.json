{
  "channel": "mall",
  "ruleCode": "ruleCode02",
  "modelCode": "modelCode01",
  "ruleName": "ruleName02",
  "ruleDesc": "ruleDesc02",
  "combinedConditionOperator": 1,
  "warnMessage": "逮捕羊毛党",
  "warnInterval": 300000,
  "status": 1,
  "ruleConditionGroup": [
    {
      "ruleCode": "ruleCode02",
      "eventCode": "eventCode03",
      "eventThreshold": 20,
      "conditionType": 1,
      "beginTime": "1970-01-01 00:00:00",
      "endTime": "1970-01-01 00:00:00",
      "windowSize": 600000,
      "isCrossHistory": true,
      "crossHistoryTimeline": "2024-08-27 17:35:28",
      "eventInfo": {
        "eventCode": "eventCode03",
        "channel": "game",
        "eventName": "登陆",
        "eventDesc": "商城登陆",
        "eventAttributeGroup": [
          {
            "eventCode": "eventCode03",
            "fieldName": "campaignId",
            "fieldDesc": "活动ID"
          },
          {
            "eventCode": "eventCode03",
            "fieldName": "campaignName",
            "fieldDesc": "活动名称"
          }
        ]
      }
    },
    {
      "ruleCode": "ruleCode02",
      "eventCode": "eventCode04",
      "eventThreshold": 10,
      "conditionType": 1,
      "beginTime": "1970-01-01 00:00:00",
      "endTime": "1970-01-01 00:00:00",
      "windowSize": 300000,
      "isCrossHistory": false,
      "crossHistoryTimeline": "1970-01-01 00:00:00",
      "eventInfo": {
        "eventCode": "eventCode04",
        "channel": "game",
        "eventName": "下单",
        "eventDesc": "商城下单",
        "eventAttributeGroup": [
          {
            "eventCode": "eventCode04",
            "fieldName": "campaignId",
            "fieldDesc": "活动ID"
          },
          {
            "eventCode": "eventCode04",
            "fieldName": "campaignName",
            "fieldDesc": "活动名称"
          }
        ]
      }
    }
  ],
  "ruleModelGroovyCode": "package com.liboshuai.starlink.slr.engine.processor.impl;\n\nimport com.liboshuai.starlink.slr.engine.api.constants.GlobalConstants;\nimport com.liboshuai.starlink.slr.engine.api.constants.RedisKeyConstants;\nimport com.liboshuai.starlink.slr.engine.api.dto.EventKafkaDTO;\nimport com.liboshuai.starlink.slr.engine.api.dto.RuleConditionDTO;\nimport com.liboshuai.starlink.slr.engine.api.dto.RuleInfoDTO;\nimport com.liboshuai.starlink.slr.engine.api.enums.RuleConditionOperatorTypeEnum;\nimport com.liboshuai.starlink.slr.engine.convert.EventKeyConvert;\nimport com.liboshuai.starlink.slr.engine.dto.WarnInfoDTO;\nimport com.liboshuai.starlink.slr.engine.exception.BusinessException;\nimport com.liboshuai.starlink.slr.engine.processor.Processor;\nimport com.liboshuai.starlink.slr.engine.utils.data.RedisUtil;\nimport com.liboshuai.starlink.slr.engine.utils.date.DateUtil;\nimport com.liboshuai.starlink.slr.engine.utils.string.JsonUtil;\nimport com.liboshuai.starlink.slr.engine.utils.string.StringUtil;\nimport org.apache.flink.api.common.functions.RuntimeContext;\nimport org.apache.flink.api.common.state.MapState;\nimport org.apache.flink.api.common.state.MapStateDescriptor;\nimport org.apache.flink.api.common.state.ValueState;\nimport org.apache.flink.api.common.state.ValueStateDescriptor;\nimport org.apache.flink.api.common.typeinfo.Types;\nimport org.apache.flink.util.CollectionUtil;\nimport org.apache.flink.util.Collector;\nimport org.apache.flink.util.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.time.LocalDateTime;\nimport java.util.*;\n\n/**\n * 运算机one\n */\npublic class ProcessorOne implements Processor {\n\n    private static final Logger log = LoggerFactory.getLogger(ProcessorOne.class);\n\n    /**\n     * smallValue（窗口步长）: key为eventCode,value为eventValue\n     */\n    private MapState<String, Long> smallMapState;\n\n    /**\n     * 记录对应eventCode是否已经初始化过\n     */\n    private MapState<String, Object> smallInitMapState;\n\n    /**\n     * bigValue（窗口大小）: key为eventCode，小map的key为时间戳，小map的value为一个一个步长的eventValue累加值\n     */\n    private MapState<String, Map<Long, Long>> bigMapState;\n\n    /**\n     * 最近一次预警时间\n     */\n    private ValueState<Long> lastWarningTimeState;\n\n    /**\n     * key详情信息（主要用于预警信息）\n     */\n    private ValueState<WarnInfoDTO> warnInfoState;\n\n    @Override\n    public void init(RuntimeContext runtimeContext, RuleInfoDTO ruleInfoDTO) {\n        String ruleCode = ruleInfoDTO.getRuleCode();\n        smallMapState = runtimeContext.getMapState(\n                new MapStateDescriptor<>(\"smallMapState_\" + ruleCode, String.class, Long.class)\n        );\n        smallInitMapState = runtimeContext.getMapState(\n                new MapStateDescriptor<>(\"smallInitMapState\" + ruleCode, String.class, Object.class)\n        );\n        bigMapState = runtimeContext.getMapState(\n                new MapStateDescriptor<>(\"bigMapState_\" + ruleCode, Types.STRING, Types.MAP(Types.LONG, Types.LONG))\n        );\n        lastWarningTimeState = runtimeContext.getState(\n                new ValueStateDescriptor<>(\"lastWarningTimeState_\" + ruleCode, Long.class)\n        );\n        warnInfoState = runtimeContext.getState(\n                new ValueStateDescriptor<>(\"warnInfoState_\" + ruleCode, WarnInfoDTO.class)\n        );\n    }\n\n    @Override\n    public void processElement(long timestamp, EventKafkaDTO eventKafkaDTO, RuleInfoDTO ruleInfoDTO, Collector<String> out) throws Exception {\n        if (Objects.isNull(ruleInfoDTO)) {\n            throw new BusinessException(\"运算机 ruleInfoDTO 必须非空\");\n        }\n        String eventKafkaDTOChannel = eventKafkaDTO.getChannel();\n        String ruleInfoChannel = ruleInfoDTO.getChannel();\n        if (!Objects.equals(eventKafkaDTOChannel, ruleInfoChannel)) {\n            return;\n        }\n        // 获取规则条件\n        List<RuleConditionDTO> ruleConditionList = ruleInfoDTO.getRuleConditionGroup();\n        if (CollectionUtil.isNullOrEmpty(ruleConditionList)) {\n            throw new BusinessException(\"运算机 ruleConditionList 必须非空\");\n        }\n        // 多个规则条件进行窗口值累加\n        for (RuleConditionDTO ruleConditionDTO : ruleConditionList) {\n            if (Objects.equals(eventKafkaDTO.getEventCode(), ruleConditionDTO.getEventCode())) { // 事件编号匹配上\n                // 更新预警所需信息\n                WarnInfoDTO warnInfoDTO = EventKeyConvert.INSTANCE.eventKafkaDTO2WarnInfoDTO(eventKafkaDTO);\n                warnInfoState.update(warnInfoDTO);\n                // 状态值防空\n                if (smallMapState.get(eventKafkaDTO.getEventCode()) == null) {\n                    smallMapState.put(eventKafkaDTO.getEventCode(), 0L);\n                }\n                if (ruleConditionDTO.getIsCrossHistory()) { //跨历史时间段\n                    LocalDateTime crossHistoryTimeline = ruleConditionDTO.getCrossHistoryTimeline();\n                    // 因为跨历史时间段的规则条件需要处理历史缓存的数据，而历史缓存的数据可能过多，所以需要根据历史截止点进行过滤，仅需要大于历史截止点的数据\n                    if (eventKafkaDTO.getTimestamp() > DateUtil.convertLocalDateTime2Timestamp(crossHistoryTimeline)) {\n                        // 因为跨历史时间段的规则条件需要从redis中获取doris中历史事件值，所以检查当前值是否已经通过redis初始化后，防止重复初始化\n                        if (!smallInitMapState.contains(eventKafkaDTO.getEventCode())) {\n                            // 如果为跨历史时间段的，且还没有初始化，则需要从redis中获取初始值\n                            String key = RedisKeyConstants.DORIS_HISTORY_VALUE\n                                    + GlobalConstants.REDIS_KEY_SEPARATOR + ruleConditionDTO.getRuleCode()\n                                    + GlobalConstants.REDIS_KEY_SEPARATOR + ruleConditionDTO.getEventCode();\n                            String keyCode = eventKafkaDTO.getKeyCode();\n                            String initValue = RedisUtil.hget(key, keyCode);\n                            if (StringUtils.isNullOrWhitespaceOnly(initValue)) {\n                                throw new BusinessException(StringUtil.format(\"从redis获取初始值必须非空, key:{}, hashKey: {}\", key, keyCode));\n                            }\n                            smallMapState.put(eventKafkaDTO.getEventCode(), Long.parseLong(initValue));\n                            smallInitMapState.put(eventKafkaDTO.getEventCode(), null);\n                        }\n                        // 从redis初始化值后，正常处理数据\n                        smallMapState.put(eventKafkaDTO.getEventCode(),\n                                smallMapState.get(eventKafkaDTO.getEventCode()) + Long.parseLong(eventKafkaDTO.getEventValue()));\n                    }\n                } else { // 非跨历史时间段\n                    // 对于非跨历史时间段，只处理当前一条数据，不需要处理历史缓存数据\n                    if (eventKafkaDTO.getTimestamp() == timestamp) {\n                        smallMapState.put(eventKafkaDTO.getEventCode(),\n                                smallMapState.get(eventKafkaDTO.getEventCode()) + Long.parseLong(eventKafkaDTO.getEventValue()));\n                    }\n                }\n            }\n        }\n    }\n\n    @Override\n    public void onTimer(long timestamp, RuleInfoDTO ruleInfoDTO, Collector<String> out) throws Exception {\n        if (Objects.isNull(ruleInfoDTO)) {\n            throw new BusinessException(\"运算机 ruleInfoDTO 必须非空\");\n        }\n        // 获取规则条件\n        List<RuleConditionDTO> ruleConditionList = ruleInfoDTO.getRuleConditionGroup();\n        if (CollectionUtil.isNullOrEmpty(ruleConditionList)) {\n            throw new BusinessException(\"运算机 ruleConditionList 必须非空\");\n        }\n        // 将规则条件根据事件编号存储到map中，方便后续操作\n        Map<String, RuleConditionDTO> ruleConditionMapByEventCode = new HashMap<>();\n        for (RuleConditionDTO ruleConditionDTO : ruleConditionList) {\n            ruleConditionMapByEventCode.put(ruleConditionDTO.getEventCode(), ruleConditionDTO);\n        }\n        // 将每个事件窗口步长数据集累加的值，添加到窗口大小数据集中bigMapState中\n        updateBigMapWithSmallMap(timestamp);\n        // 清理窗口大小之外的数据\n        cleanupWindowData(timestamp, ruleConditionMapByEventCode);\n        // 判断是否触发规则事件阈值\n        boolean eventResult = evaluateEventThresholds(ruleConditionMapByEventCode, ruleInfoDTO);\n        // 根据规则中事件条件表达式组合判断事件结果 与预警频率 判断否是触发预警\n        if (lastWarningTimeState.value() == null) {\n            lastWarningTimeState.update(0L);\n        }\n        WarnInfoDTO warnInfoDTO = warnInfoState.value();\n        if (eventResult && (timestamp - lastWarningTimeState.value() >= ruleInfoDTO.getWarnInterval())) {\n            lastWarningTimeState.update(timestamp);\n            // TODO: 进行预警信息拼接组合\n            log.warn(\"{}渠道的{}({})用户触发了{}({})规则，请尽快处理!\",\n                    warnInfoDTO.getChannel(), warnInfoDTO.getKeyCode(), warnInfoDTO.getKeyValue(),\n                    ruleInfoDTO.getRuleName(), ruleInfoDTO.getRuleCode());\n            out.collect(StringUtil.format(\"{}渠道的{}({})用户触发了{}({})规则，请尽快处理!\",\n                    warnInfoDTO.getChannel(), warnInfoDTO.getKeyCode(), warnInfoDTO.getKeyValue(),\n                    ruleInfoDTO.getRuleName(), ruleInfoDTO.getRuleCode()));\n        }\n        // 调试使用，待删除\n        logBigMapState(ruleInfoDTO.getRuleCode(), ruleConditionMapByEventCode.keySet(),\n                warnInfoDTO == null ? null : warnInfoDTO.getKeyCode(), bigMapState);\n    }\n\n    /**\n     * 判断是否触发规则事件阈值\n     */\n    private boolean evaluateEventThresholds(Map<String, RuleConditionDTO> ruleConditionMapByEventCode, RuleInfoDTO ruleInfoDTO) throws Exception {\n        Map<String, Boolean> eventCodeAndWarnResult = new HashMap<>();\n        for (Map.Entry<String, Map<Long, Long>> bigMapEntry : bigMapState.entries()) {\n            String eventCode = bigMapEntry.getKey();\n            Map<Long, Long> timestampAndEventValueMap = bigMapEntry.getValue();\n            long eventValueSum = timestampAndEventValueMap.values().stream().mapToLong(Long::longValue).sum();\n            Long eventThreshold = ruleConditionMapByEventCode.get(eventCode).getEventThreshold();\n            eventCodeAndWarnResult.put(eventCode, eventValueSum > eventThreshold);\n        }\n        boolean eventResult = evaluateEventResults(eventCodeAndWarnResult, ruleInfoDTO.getCombinedConditionOperator());\n        return eventResult;\n    }\n\n    /**\n     * 将每个事件窗口步长数据集累加的值，添加到窗口大小数据集中bigMapState中\n     */\n    private void updateBigMapWithSmallMap(long timestamp) throws Exception {\n        for (Map.Entry<String, Long> smallMapEntry : smallMapState.entries()) {\n            String eventCode = smallMapEntry.getKey();\n            Long eventValue = smallMapEntry.getValue();\n            Map<Long, Long> timestampAndEventValueMap = bigMapState.get(eventCode);\n            if (CollectionUtil.isNullOrEmpty(timestampAndEventValueMap)) {\n                timestampAndEventValueMap = new HashMap<>();\n            }\n            timestampAndEventValueMap.put(timestamp, eventValue);\n            bigMapState.put(eventCode, timestampAndEventValueMap);\n        }\n        // 当前窗口步长的数据已经添加到窗口中了，清空状态\n        smallMapState.clear();\n    }\n\n    /**\n     * 清理窗口大小之外的数据\n     */\n    private void cleanupWindowData(long timestamp, Map<String, RuleConditionDTO> ruleConditionMapByEventCode) throws Exception {\n        for (Map.Entry<String, Map<Long, Long>> bigMapEntry : bigMapState.entries()) {\n            String eventCode = bigMapEntry.getKey();\n            Map<Long, Long> timestampAndEventValueMap = bigMapEntry.getValue();\n            Long windowSize = ruleConditionMapByEventCode.get(eventCode).getWindowSize();\n            long twentyMinutesAgo = timestamp - windowSize;\n            Iterator<Map.Entry<Long, Long>> iterator = timestampAndEventValueMap.entrySet().iterator();\n            while (iterator.hasNext()) {\n                Map.Entry<Long, Long> next = iterator.next();\n                Long time = next.getKey();\n                if (time <= twentyMinutesAgo) {\n                    iterator.remove();\n                }\n            }\n            bigMapState.put(eventCode, timestampAndEventValueMap);\n        }\n    }\n\n    private void logSmallMapState(String ruleCode, List<String> eventCodeList, String keyCode,\n                                  MapState<String, Long> smallMapState) throws Exception {\n        Map<String, Long> smallMap = new HashMap<>();\n        Iterator<Map.Entry<String, Long>> iterator = smallMapState.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String, Long> next = iterator.next();\n            smallMap.put(next.getKey(), next.getValue());\n        }\n        log.warn(\"ProcessorOne对象processElement方法结束; ruleCode={}, eventCodeList={}, keyCode={}, smallMapState={}\",\n                ruleCode, JsonUtil.toJsonString(eventCodeList), keyCode, JsonUtil.toJsonString(smallMap));\n    }\n\n    private void logBigMapState(String ruleCode, Set<String> eventCodeList, String keyCode, MapState<String,\n            Map<Long, Long>> bigMapState) throws Exception {\n        Map<String, Map<Long, Long>> bigMap = new HashMap<>();\n        Iterator<Map.Entry<String, Map<Long, Long>>> iterator = bigMapState.iterator();\n        while (iterator.hasNext()) {\n            Map.Entry<String, Map<Long, Long>> next = iterator.next();\n            bigMap.put(next.getKey(), next.getValue());\n        }\n        log.warn(\"ProcessorOne对象onTimer方法结束; ruleCode={}, eventCodeList={}, keyCode={}, bigMapState={}\",\n                ruleCode, JsonUtil.toJsonString(eventCodeList), keyCode, JsonUtil.toJsonString(bigMap));\n    }\n\n    /**\n     * 评估事件结果，根据给定的条件操作符返回最终结果。\n     *\n     * @param eventCodeAndWarnResult 包含事件代码及其对应的警告结果的映射\n     * @param conditionOperator      条件操作符，支持 AND 和 OR\n     * @return 根据条件操作符计算后的最终结果（true 或 false）\n     */\n    public static boolean evaluateEventResults(Map<String, Boolean> eventCodeAndWarnResult, Integer conditionOperator) {\n        if (CollectionUtil.isNullOrEmpty(eventCodeAndWarnResult)) {\n            return false;\n        }\n        if (CollectionUtil.isNullOrEmpty(eventCodeAndWarnResult.values())) {\n            return false;\n        }\n        // 初始化结果变量，根据条件操作符判断初始值\n        boolean result = conditionOperator.equals(RuleConditionOperatorTypeEnum.AND.getCode());\n\n        // 遍历事件结果的 Map\n        for (Boolean eventResult : eventCodeAndWarnResult.values()) {\n            if (conditionOperator.equals(RuleConditionOperatorTypeEnum.AND.getCode())) {\n                // 对于 AND，只有当所有结果都为 true 时，结果才为 true\n                result = eventResult;\n                // 提前结束循环，如果结果已经为 false\n                if (!result) {\n                    break;\n                }\n            } else if (conditionOperator.equals(RuleConditionOperatorTypeEnum.OR.getCode())) {\n                // 对于 OR，只要有一个结果为 true，结果就为 true\n                result = eventResult;\n                // 提前结束循环，如果结果已经为 true\n                if (result) {\n                    break;\n                }\n            }\n        }\n        // 返回最终的评估结果\n        return result;\n    }\n\n}\n"
}